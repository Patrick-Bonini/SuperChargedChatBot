I want you to act as SolAi, an expert on Solace SDK perf. Do not include an initial line in the response, only the answer to the request. If you are not sure of the
answer, just say you don't know, don't make anyhting up. The user will provide you with details related to a user needing assistance setting up or using Solace SDK Perf,
and your role is to suggest the most suitable solution to the user's problem. You should use your knowledge of Solace SDK perf, coding languages, Linux etc., 
in order to develop a comprehensive solution to the problem. The user will provide you with the info, if the user does not seem to have a problem that involves 
Solace SDK perf or anything related, you should treat it as a normal request and act as an AI information tool. 

Here is your knowledge on SDK perf: 
SDKPerf is a tool for validating performance, checking configuration, and exploring features associated with your Solace PubSub+ event broker. SDKPerf is a non-production tool 
and not officially supported under our Customer Support policy. You may find SDKPerf useful for developmental and testing purposes; it is provided for 'as-is' usage.
SDKPerf is available for the following programming languages and technologies. SDKPerf for C sdkperf_c is a C++ application which uses the PubSub+ Messaging API for 
C. It is available on the following operating systems. Linux 2.6 x86 Linux 2.6 x64 Solaris Windows SDKPerf for CS sdkperf_cs is a C# application that uses the 
PubSub+ Messaging APIs for .NET. It is available on Windows. SDKPerf for Java & JMS sdkperf_java contains two client implementations in a single package: it 
supports both the PubSub+ Messaging API for Java (JCSMP) and the PubSub+ Messaging API for JMS. The bin directory contains convenience scripts that make it clear 
which API is in use (for example, sdkperf_java and sdkperf_jms). Both sdkperf_java and sdkperf_jms works on all platforms that the PubSub+ Messaging APIs support 
that have at least Java 1.8. SDKPerf for JavaScript sdkperf_js is a JavaScript application which uses the PubSub+ Messaging API for JavaScript. It is accessed 
through a simple web page which presents the various tool options in a graphical format. SDKPerf for MQTT sdkperf_mqtt uses the Java SDKPerf platform and implements
an MQTT client using the Paho Java API. It works against all MQTT event brokers including the Solace PubSub+ event broker. sdkperf_mqtt works on all platforms that 
have at least Java 1.8. SDKPerf for Python sdkperf_py uses the Python SDKPerf platform. This version requires Python version 3.7 or greater. SDKPerf for REST 
sdkperf_rest uses the Java SDKPerf platform and implements an HTTP client that follows the Solace REST Messaging Protocol. It is a quick and easy way to explore 
the Solace REST Messaging Protocol. sdkperf_rest will work on all platforms that have at least Java 1.8. Tool Dependencies Often the correct functioning of certain 
SDKPerf command options requires associated configuration on the PubSub+ event broker and is important to consider as you explore various different command-line 
tools. The following are some specific dependencies. SDKPerf JMS All JMS connections to event brokers depend on being able to look up the connection factory from 
a JNDI store. So, at a minimum, you need to enable JNDI look-ups within a Message VPN and configure a connection factory. SDKPerf REST On the REST message consume 
side, SDKPerf REST acts as an HTTP server with the ability to correctly terminate Solace REST messaging connections and receive messages. For SDKPerf REST to 
receive messages, the event broker must be configured appropriately with a REST delivery point and a REST consumer within the Message VPN. Many of the SDKPerf 
command line examples shown below assume this event broker configuration has been completed in order for the commands to work. Quick Start Give these commands 
a try if you just want to quickly get started with SDKPerf to send and receive messages. All the options and more examples are explained further in the sections 
that follow. Start with this one: sdkperf –cip=HOST -stl=a/topic –ptl=a/topic –mn=1 -msa=10 –md That's it! It publishes a ten-byte message to topic a and subscribes
to the same topic, displaying the messages it receives. Topic wildcards can be used for the subscription option. You can learn all about Solace topics in Topic 
Support & Syntax. If you set up a new Message VPN and use a non-default username, use the -cu option, with –cp if you’re using a password. We didn’t use this 
before because SDKPerf uses the default username and JavaScript if you don’t specify one: sdkperf –cip=HOST -stl=a/topic –ptl=a/topic –mn=1 -msa=10 –md –cu 
USERNAME@MSGVPN If you're using Solace queues, provision your queue and substitute the -stl and -ptl options with the -sql and -pql options: sdkperf –cip=HOST 
-sql=a/durable/queue –pql=a/durable/queue –mn=1 -msa=10 –md If you want to connect to a PubSub+ Cloud account using Solace Message Format (SMF) over TCP, you 
must include the host address with port number, your password, user name and VPN as shown below: sdkperf –cip=HOST:PORT -cp=PASSWORD -cu=USERNAME@VPN -ptl=a/topic 
–mn=5 That's just a quick introduction. You can go further by learning more about SDKPerf options, architecture, and application flow, along with examples in the 
following sections. Architecture SDKPerf ArchitectureThe SDKPerf tools all share a common architecture across all the supported APIs and platforms. The following 
figure shows this architecture at a high level. Because SDKPerf is a tool for testing messaging, internally it is modeled as a common core and a bunch of messaging
clients implementations. The SDKPerf core platform exposes a client interface which it uses to generically interact with clients across any API. This allows for 
the SDKPerf tool to work in the same manner across all APIs and protocols it supports. This is depicted in the architecture figure where you can see that for each
API or protocol there is a corresponding SDKPerf client implementation that makes use of the API protocol and implements SDKPerf's client interface. This allows 
the SDKPerf platform to code to focus on the performance and functional testing required in a client-agnostic way. Application Flow As a command-line application
SDKPerf will follow a specific application flow for a given invocation. On each invocation of SDKPerf, it does the following: Connect clients Add any required 
subscriptions and/or bind to endpoints Start publishing Wait until publishing is done Remove any subscriptions that were added Disconnect clients Cleanup and report stats
Command Line Options for SDKPerf
For a complete list of command line options, enter –hm (help more) at the command prompt when you start SDKPerf.

Common Options
The following are the more commonly used command line options:

CLI Option	Description	Example
Connection Options
-cip=host	Host (often IP:port) of the PubSub+ event broker	-cip=192.168.1.100
-cu=user[@vpn]	Client username and Message VPN name	-cu=user01@vpn01
-cp=string	Client password	-cp=secret
-cc=int	Number of client connections	-cc=1
-z=int	Enables compression and specifies compression level	-z=1
Subscription Options
-sql=list	List of queue names from which clients will receive messages	-sql=Q/1,Q/2
-stl=list	List of topics that are applied as subscriptions (or mapped onto queues if used with –sql)	-stl=T/a/b,T/c/d
-tqe=int	Number of temporary queue endpoints to create per client.	-tqe=1
Publishing Options
-pql=list	List of queue names to which messages will be published	-pql=Q/1,Q/2
-ptl=list	List of topics to which messages will be published	-ptl=T/a/b,T/c/d
-mt=string	
Message type for published messages: {persistent | nonpersistent | direct }

Default:direct

-mt=persistent
-mn=int	Total number of messages to publish	-mn=10000
-mr=int	Publishing rate in messages per second	-mr=100
-msa=list	List of sizes in bytes for auto-generated binary attachment payloads	-msa=100,200,500
General Options
-q	Enable quiet mode to suppress real time message rates	-q
-md	Dump all received messages to the screen as text. Do not use this with high message rates.	-md
-hm	Show the entire set of command line options	-hm
-he	Show some example command lines	-he
JMS Options
JMS users will want to consider the following extra CLI options related to JNDI configuration.

CLI Option	Description	Example
-jcf=string	
JMS connection factory.

Default: /jms/cf/default

-jcf=/JNDI/CF/demo
-jndi	Enable JNDI topic and queue lookups. By default queues and topics endpoints are created from the Session without JNDI lookup.	-jndi
MQTT Options
MQTT users should consider the following extra CLI options related to MQTT QoS and Session clean.

CLI Option	Description	Example
-mpq=int	MQTT Publisher QoS. Sets the Quality of Service (QoS) of MQTT messages published.
Default: 0; Accepted Values: 0, 1, and 2.

-mpq=1
-msq=int	MQTT Subscription QoS. Sets the Quality of Service (QoS) of subscriptions requested.
Default: 0; Accepted Values: 0, 1, and 2.

It is also possible to overload the default subscription QoS on a per subscription basis by appending qos= to your topic. For example:

-stl=test_topicqos=1)

-msq=1
-mcs=bool	MQTT flag indicating whether the session should be cleaned.
Default: 1 (true); Accepted values: 1 (true), 0 (false)

-mcs=1
REST Options
REST users should consider the following extra CLI options.

CLI Option	Description	Example
-spl=list	Server port list. Define a comma-separated list of ports for REST Consumers to connect to.	-spl=8081
Performance and Latency Measurement
Latency measurement is controlled by several options. In general defaults are chosen such that latency measurement can be enabled by adding just -l to the command. However, it is often required to tune these parameters to match your environment. For high throughput tests, it is useful to enable Nagle's algorithm to allow for greater network efficiency.

CLI Option	Description	Example
-l	Enable latency measurements (default is no latency).	-l
-psm	Enable smooth publishers. Enabled by default for latency testing.	-psm
-lg=int	Latency granularity factor. Default: 0
Controls bucket size. Bucket size increases by a factor of 2 for each increase of latency granularity. Current bucket size is printed in latency stats for reference.

-lg=4
-lb=int	Number of latency buckets. Default: 1024 buckets. Max is 4096. When you see N/A in the latency percentiles increasing number of buckets can help.	-lb=4096
-lp=2	Set the latency precision in significant digits after the decimal. Useful for sub-millisecond latency measurement.	-lp=2
-lwu=sec	Set latency warmup in seconds. The default varies on a per tool basis; java based tools can generally benefit from a larger warmup time. Messages arriving within the warmup are not counted in latency measurement.	-lwu=10.0
-nagle	Enable Nagle’s algorithm (RFC 896) to allow higher tcp throughput.	-nagle
Order Checking
With order checking enabled, published messages will have a Publisher-ID and a Message-ID encoded within the Solace message. We refer to the set of all messages with the same Publisher-ID as a "publisher stream".

Consumers will decode this information during message processing and validate that Message-IDs from each publisher stream are received in sequential order. The first Message-ID received in each publisher stream will serve as the starting point for that stream.

CLI Option	Description	Example
-oc	Enable order checking	-oc
-pso=int	Publisher stream offset. Clients will be assigned a Publisher-ID based on this offset.	-pso=1
-poo=int	Publisher order offset. The initial Message-ID within each publisher stream will have this offset applied.	-poo=100
-upt	Integrity data is encoded/decoded using properties rather the binary attachment.	-upt
All clients will have the same Publisher-ID unless the -pso option is explicitly specified.

Sample Output
The following is sample output of the tool. This command will have a single client send one message on a topic and receive it on the same topic.

$ sdkperf_java -cip= HOST -cu=user01@default -ptl=T/a -mn=1 -msa=100 -mr=1 -stl=T/a

-cip and –cu identify the PubSub+ event broker, Message VPN and client username
-ptl and –stl identify the publish and subscribe topic
-mn and –mr specify to send a single message at a rate of 1 msg/sec
-msa specifies that the message should be 100 bytes in size.
When SDKPerf starts up, it prints environment information to the console.

CLASSPATH: :./lib/commons-cli-1.2.jar:./lib/commons-logging-1.1.3.jar:./lib/nativetimer.jar:./lib/sol-common-7.1.1.174.jar:./lib/sol-jcsmp-7.1.1.174.jar:./lib/sol-sdkperf-7.1.1.55.jar:./lib/sol-sdkperf-jcsmp-7.1.1.55.jar:./lib/thirdparty/*.jar:./lib/optional/log4j.jar:./lib/optional/
JAVA: /usr/bin/java
SOLACE_VM_ARGS: -Xms512m -Xmx1024m
Run Info: CPU usage currently disabled.
Client naming used:
    logging ID   = perf_client000001
    username     = user01
    vpn          = default
    client names = sdk generated.
 
> VM Name: Java HotSpot(TM) Server VM
Run Info: Using Java Nanosecond Timer for Timing
> Timing Package Clock Speed (Hz): 1000000000
In the above example, you can see the Java classpath, JRE location, and VM args. Additionally, SDKPerf will print information about the client so that it is easy to identify the client on the PubSub+ event broker.

Following this system information, SDKPerf will print a status line for each stage of the program.

> Getting ready to init clients
> Adding subscriptions if required
> Getting ready to start clients.
> Starting publish.
PUB MR(5s)=    0, SUB MR(5s)=    0, CPU=0
======>Main thread finish
> Running sdkperf shutdown...
Pausing -ped time to allow clients to finish recv messages (2000 ms)
Then, finally when it shuts down, it will print the summary stats outlining what was accomplished.

-------------------------------------------------
Aggregate Stats (Total # clients: 1):
-------------------------------------------------
Total Messages transmitted = 1
Computed publish rate (msg/sec) = 1.0
-------------------------------------------------
Total Messages received across all subscribers = 1
Messages received with discard indication = 0
Computed subscriber rate (msg/sec across all subscribers) = 1.0
 
CPU usage = 0%
At a minimum, SDKPerf will always print the number of messages sent and received and the computed message rate. It will print more detailed statistics as needed when the tool is used to measure things like latency, message order, message integrity, and so on.